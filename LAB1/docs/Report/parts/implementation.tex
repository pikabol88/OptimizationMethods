\documentclass[../body.tex]{subfiles}
\begin{document}
	\subsection{Алгоритм перевода из общей в каноническую форму}
	\textbf{Вход}: система уравнений
	\begin{enumerate}
		\item Проверяем знаки в системе
		\item Если <<$\le$>>, то к левой части добавляем $w[i]$, если <<$\ge$>>, то из левой части вычитаем $w[i]$, $w[i]\ge0$.
		\item Знаки неравенства в системе заменяем на равенство.
		\item Производим замену переменных: \\если $x[i]\le0$, то $x'[i]=-x[i]\ge0$; \\если $x[i]$ любого знака, то $x[i]=u[i]-v[i]$, $v[i],u[i] \ge 0$.
	\end{enumerate}
	\subsection{Алгоритм построения двойственной задачи}
Рассмотрим задачу минимума:
	\begin{equation}
		\begin{array}{ll}\label{eq:problem}
			(x[N],c[N])\longrightarrow \min_{x[N]}, x[N] \in S, x[N] \ge 0\\
			S :=\{x[N]|A[M,N]\cdot x[N] \gtreqless b[M]\}, x[N] \ge 0
		\end{array}
	\end{equation}
	Если же перед нами стоит задача максимума, то домножим вектор коэффициентов матрицы цели на $-1$.
	\begin{enumerate}
		\item Транспонируем заданную матрицу $ A^{T}$
		\item Новый вектор коэффицентов, стоящий в системе справа, равен вектору коэффициентов функции цели (\ref{eq:goal}).
		\item Новый вектор коэффициентов функции цели равен вектору коэффицентов, стоящему в системе (\ref{eq:limitation}) справа.
		\item Если ограничение на $x[i]\ge0$, то $i$-ая строка новой системы имеет знак <<$\le$>>.
		Если нет ограничения на знак, то $i$-ая строка новой системы имеет знак <<$=$>>.
		\item Если ограничение $i$-ой строки в исходной системе <<$\ge$>> (тк рассматриваем задачу  минимума), то ограничение на знак новой переменной $y[i]\ge0$.
		Если ограничение $i$-ой строки в исходной системе <<$=$>>, то $y[i]$ любого знака.
		\item Если исходная задача на поиск минимума, то двойственная на поиск максимума.
	\end{enumerate}
	\subsection{Алгоритм симплекс-метода}
	
	
	\textbf{Рассмотрим алгоритм в качестве псевдокода:}\\
	\SetKwRepeat{Do}{do}{while}
	\begin{algorithm}[H]
		\KwData{задача линейного программирования
			в стандартной форме}
		\KwResult{$n$-мерный вектор $\bar{x}=\left(\bar{x}_{j} \right) $, который является оптимальным решением задачи линейного программирования}
		\textbf{$Simplex(A,b,c):$}\\
		$(N,B,A,b,c,v) = Initialize-Simplex(A,b,c)$\\\
			Пусть $\Delta$ - новый вектор длиной $m$\\
		\While{$c_{j}$>0 для некоторого индекса $j \in N$}{
			Выбрать индекс $e\in B$, для которого $c_{e}>0$\\
			\For{каждого индекса $i \in B$}{
				\eIf{$a_{ie}>0$}{$\Delta_{i} = b_{i}/a_{ie}$}{$\Delta_{i} = \infty$}
			}
			Выбрать индекс $l \in B$, который минимизирует $\Delta_{l}$\
			
			\eIf{$\Delta_{l} == \infty$}{\textbf{return} задача неограничена}{$(N,B,A,b,c,v) = Pivot(N,B,A,b,c,v, l, e)$}
			\For{$i=1$ \textbf{to} $n$}{
				\eIf{$i\in B$}{
					$\bar{x}_{i}=b_{i}$
				}{
					$\bar{x}_{i}=0$
				}
			}
			\textbf{return} $(\bar{x}_{i}, \bar{x}_{2}, ... , \bar{x}_{n})$
		}
	
		\caption{Симплекс-метод решения задачи линейного программирования}
		
\end{algorithm}

\vspace{\baselineskip}

Процедура \textbf{Simplex} работает следующим образом:
\begin{itemize}
	\item В строке $2$ выполняется процедура $Initialize-Simplex(A,b,c)$, которая или определяет, что предложенная задача неразрешима, или возвращает каноническую форму, базисное решение которой является допустимым.
	
	 Если в системе имеется единичная матрица, то в качестве начальных базисных переменных принимают те компоненты, которым соответствует eё столбцам\\

	 
	 	\begin{algorithm}[H]
	 	\KwData{задача линейного программирования
	 		в стандартной форме}
	 	\KwResult{или
	 		определяет, что предложенная задача неразрешима, или возвращает каноническую форму, базисное решение которой является допустимым }
	 	\textbf{$Initialize-Sim plex(A,b,c):$}\\
	 	Пусть $k$ - является индексом минимального $b_i$\\
	 	\If{$b_k\geq 0$ // Допустимо ли начальное базисное решение?}{\textbf{return} ($\left\lbrace 1 , 2 ,..., n\right\rbrace  , \left\lbrace n + 1 , n + 2 ,..., n + m \right\rbrace , A,b,c, 0 )$}
	 	Образуем $  L_{aux}$ путем добавления — $x_{0}$ к левой части каждого
	 	ограничения и задаем целевую функцию — $x_{0}$\\
	 	Пусть $(N,B,A,b,c,v)$ представляет собой результирующую
	 	каноническую форму для $L_{aux}$
\\
	 	$l = n + k$\\
	 	// $L_{aux}$ имеет $n+1$ небазисную и $ m $ базисных переменных\\
	 	$(N ,B ,A ,b ,c ,v ) = Pivot(N,B, A ,b ,c ,v ,l,0 )$\\
	 	// Базисное решение является допустимым для $L_{aux}$ \\
	 	Выполняем итерации цикла while в строках 3-12 процедуры
	 	$Simplex$, пока не будет найдено оптимальное решение
	 	задачи $L_{aux}$
\\
	 	\eIf{в оптимальном решении $L_{aux}\bar{x}_{0}=0$}{	 		
	 		\If{$\bar{x}_{0}$ является базисной переменной }{выполнить одно (вырожденное) замещение, чтобы сделать её небазисной\\В окончательной канонической форме для $L_{aux}$ удалить
	 			из ограничений $х_0$ и восстановить исходную целевую
	 			функцию $L$, но заменить в этой целевой функции
	 			каждую базисную переменную правой частью
	 			связанного с ней ограничения\\
 			\textbf{return} полученную окончательную каноническую форму}
 			
	 	}{return “задача неразрешима”}
	 	
	 	\caption{Поиск начального базисного допустимого решения
	 		задачи линейного программирования $L$, заданной в стандартной форме}
	 	
	 \end{algorithm}
	
	\item Главная часть алгоритма содержится в цикле while в строках $4-16$. 
	
	Если все коэффициенты целевой функции отрицательны, цикл while завершается. В противном случае в строке $5$ мы выбираем в качестве вводимой переменной некоторую переменную $x_{e}$, коэффициент при которой в целевой функции положителен.
	\item  Затем, в строках $6-12$, выполняется проверка каждого ограничения и выбирается то,
	которое более всего лимитирует величину увеличения  $x_{e}$. 
	
	Базисная переменная, связанная с этим
	ограничением, выбирается в качестве выводимой переменной  $x_{i}$.
	\item 
	Если ни одно из ограничений не лимитирует возможность увеличения вводимой переменной, алгоритм выдает сообщение “задача неограниченная” (строка $15$). 
	
	В противном случае в строке $17$ роли вводимой и выводимой переменных
	меняются путем вызова описанной выше процедуры  $Pivot(N,B,A,b,c,v, l, e)$
	\item 
	В строках $19-25$ вычисляется решение $(\bar{x}_{i}, \bar{x}_{2}, ... , \bar{x}_{n})$ исходной задачи линейного
	программирования путем присваивания \\ \textbf{небазисным переменным} нулевого
	значения, \\\textbf{базисным переменным}  $\bar{x}_{i}$ — соответствующих значений $b_{i}$,\\ а строка $26$ возвращает эти значения.
	\item Существует Лемма:\\ Если процедура Simplex не завершается не более чем за $\left(\begin{array}{c}n+m\\ m\end{array}\right)$ итераций,она зацикливается. \\ 
	
	Использование в программе данной леммы, позволяет избежать зацикливания алгоритма.
	
\end{itemize}


	\subsection{Алгоритм перебора опорных векторов}
	Опорные векторы можно искать прямо по определению, перебирая все возможные базисы и находя соответствующие ненулевые коэффициенты из решения СЛАУ. 
	\vspace{\baselineskip}
	\SetKwRepeat{Do}{do}{while}
	
	\begin{algorithm}[H]\label{points}
		\KwData{$A[M,N], b[M], c[N]$ -- параметры задачи линейного программирования, поставленной в канонической форме ($m=|M|, n=|N|$)}
		\KwResult{опорный вектор $x_*[N]$, минимизирующий целевую функцию $(x[N],c[N])$}
		$V:=\emptyset$ -- будущий список опорных векторов\;
		\For{$i$ в диапазоне $\{0;C_m^n\}$}{
			$A[M,N_k] := $  extractMatrix($i$)\;
			\If{$|det(A[M,N_k])| > eps$}{
				$x[N_k]:=$ inv($A[M,N_k], b[M]$)\;
				Дополняем нулями до $x[N]$\;
				Добавляем $x[N]$ в $V$\;
			}
		}
		Выбираем $x_*$  -- любой вектор из $V$\;
		\For{$v \in V$}{
			\If{$(v,c) < (x_*,c)$}{
				$x_*:=v$\;
			}
		}
		
		\caption{Метод перебора опорных векторов решения задачи линейного программирования в канонической форме}
	\end{algorithm}
	\vspace{\baselineskip}
	
	Метод перебора крайних точек заключается в следующем:
	\begin{itemize}
		\item Рассматривается матрица $ A[M,N] $, где число строк матрицы меньше, чем число столбцов ($M<N$).
		\item Генерируются квадратные матрицы, выделяемые из матрицы  $ A[M,N] $, таких матриц получится $C_M^N$.
		\item Для каждой такой квадратной матрицы проверяется, что определитель отличен от нуля $|det(A[M,N_k])| > eps$
		Если это не так, то эта матрица к рассмотрению не принимается, иначе решается соответсвенно система $ A[M, N_k]x[N]=b[M] $ и находится решение.
		\item Если оказывается, что все компоненты решения удовлетворяют неравенству $\geq 0 $, то эта точка является полученной частью компонент крайней точки. Для получения крайней точки мы просто пополняем полученное решение нулевыми значениями соответсвующих компонент.
		\item Находим значение функции цели в крайней точке и запоминаем его.
		\item Генерируем следущую матрицу и продолжаем вышеперечисленные шаги.
		\item Сравниваем сохраненные значения между собой и выбираем то решение, которое соответсвует меньшему значению функции цели.	
	\end{itemize}	
\end{document}